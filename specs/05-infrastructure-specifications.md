---
title: Infrastructure Specifications
version: 1.4
date_created: 2026-02-17
last_updated: 2026-02-17
owner: TJ Monserrat
tags: [infrastructure, gcp, cloud-run, firebase, firestore]
---

## Infrastructure Specifications

### Google Cloud Project

- **Project**: *To be created / named*
- **Primary Region**: `asia-southeast1`
- **Billing**: *Budget to be determined*

---

### Components

#### INFRA-001: Firebase Hosting

**Purpose**: Serve the Nuxt 4 SPA static assets (JS, CSS, images) globally via CDN.

**Configuration**:

- Hosting target: Static assets generated by Nuxt 4 build
- Custom domain: `tjmonsi.com`
- SSL/TLS: Managed by Firebase (automatic)
- Cache headers:
  - HTML files: `Cache-Control: no-cache` (always revalidate)
  - JS/CSS/assets with hash: `Cache-Control: public, max-age=31536000, immutable`
  - Images: `Cache-Control: public, max-age=86400`
- Firebase Functions handles SPA serving (all non-asset routes serve the SPA shell)
- **Rewrite rules** (`firebase.json`):
  - `/sitemap.xml` SHALL be rewritten to the Cloud Run backend service to proxy `tjmonsi.com/sitemap.xml` → `GET /sitemap.xml` on the backend API.

  ```json
  {
    "hosting": {
      "rewrites": [
        {
          "source": "/sitemap.xml",
          "run": {
            "serviceId": "<cloud-run-service-name>",
            "region": "asia-southeast1"
          }
        }
      ]
    }
  }
  ```

  - This ensures the sitemap URL declared in `robots.txt` (`https://tjmonsi.com/sitemap.xml`) is accessible on the frontend domain while being served by the backend.

---

#### INFRA-002: Firebase Functions

**Purpose**: Serve the Nuxt 4 SPA shell. When Nuxt 4 is deployed in SPA mode on Firebase Hosting, Firebase Functions is required to serve the SPA while Firebase Hosting serves the static JS/CSS assets.

**Reference**: https://nuxt.com/deploy/firebase

**Configuration**:

- Function runtime: Node.js (as required by Nuxt/Nitro)
- Region: `asia-southeast1` (same as Cloud Run for consistency)
- Purpose: Serve the SPA `index.html` shell for all client-side routes
- Memory: 256 MB (minimal, only serving static HTML)
- Max instances: Auto-scaled by Firebase

---

#### INFRA-003: Google Cloud Run

**Purpose**: Host the Go backend API.

**Configuration**:

| Setting              | Value                           |
| -------------------- | ------------------------------- |
| Container runtime    | Go binary in minimal Docker image |
| Region               | `asia-southeast1`               |
| Min instances        | 0 (scale to zero)               |
| Max instances        | *TBD based on budget*           |
| CPU                  | 1 vCPU (initial)                |
| Memory               | 256 MB (initial)                |
| Concurrency          | 80 (default)                    |
| Request timeout      | 30 seconds                      |
| Startup CPU boost    | Enabled                         |
| Ingress              | Internal + Cloud Load Balancing |
| VPC connector        | Connected to `personal-website-vpc` (see INFRA-009) |

**Docker Image**:

```dockerfile
# Multi-stage build
FROM golang:1.23-alpine AS builder
WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download
COPY . .
RUN CGO_ENABLED=0 GOOS=linux go build -o server .

FROM gcr.io/distroless/static-debian12
COPY --from=builder /app/server /server
EXPOSE 8080
ENTRYPOINT ["/server"]
```

**Health Check**: `GET /health` (returns `200` with `{"status": "ok"}`)

---

#### INFRA-004: Google Cloud Load Balancer

**Purpose**: Route traffic, SSL termination, and integration with Cloud Armor.

**Configuration**:

- Type: External Application Load Balancer (Global)
- Backend services:
  - Firebase Hosting (frontend)
  - Cloud Run (backend API)
- SSL Certificate: Google-managed
- URL Map routing:
  - `api.tjmonsi.com/*` → Cloud Run backend
  - `tjmonsi.com/*` → Firebase Hosting + Functions
- Subdomain routing is used to separate frontend and backend traffic.

---

#### INFRA-005: Google Cloud Armor

**Purpose**: WAF and DDoS protection.

**Policies**:

| Rule Priority | Description                              | Action    |
| ------------- | ---------------------------------------- | --------- |
| 500           | Block public access to `/health`         | Deny (403)|
| 1000          | Block known malicious IP ranges          | Deny      |
| 2000          | Rate limiting (60 req/min per IP)        | Throttle  |
| 3000          | Block SQL injection patterns             | Deny      |
| 4000          | Block XSS patterns                       | Deny      |
| 5000          | Block path traversal attempts            | Deny      |
| 9999          | Default allow                            | Allow     |

**Rate Limiting at Cloud Armor level**:

- **Primary rate limiting enforcement**: Cloud Armor handles per-IP rate limiting at the load balancer level. This eliminates the need for application-level in-memory rate counters, which would not persist across Cloud Run instance scaling events.
- **Single rate limit tier**: 60 requests per minute per IP for all clients and all endpoints. No differentiation between user types, bot detection tiers, or endpoint-specific limits.
- Action: HTTP `429` response with `Retry-After` header when limits are exceeded.
- **Progressive banning**: Offender records and ban state are stored in Firestore (`rate_limit_offenders` collection, DM-009). The Go application checks Firestore for ban status on each request and enforces progressive banning logic (see SEC-002 in [06-security-specifications.md](06-security-specifications.md)).
- Note: Cloud Armor provides the rate limiting layer; the application reads offender state from Firestore to enforce progressive banning tiers (429 → 403 → 404).

**Adaptive Protection**:

- Cloud Armor Adaptive Protection SHALL be enabled to provide automatic, ML-based escalating DDoS mitigation.
- Adaptive Protection complements the manual rate-limiting rules by automatically detecting and mitigating L7 DDoS attacks without manual rule updates.
- Reference: [Cloud Armor Adaptive Protection](https://cloud.google.com/armor/docs/adaptive-protection-overview)

**Custom Error Response for 429**:

- Cloud Armor SHALL be configured with a [custom error response](https://cloud.google.com/armor/docs/custom-error-responses) for HTTP 429 status codes.
- The custom error response SHALL return `Content-Type: application/json` with the following body:

```json
{
  "error": "Too many requests. Please try again later.",
  "retry_after": 30
}
```

- Note: Even with this custom error response configured, the frontend (FE-COMP-003) matches 429 responses by status code only and does not depend on the response body format.

---

#### INFRA-006: Database

**Technology**: Firestore Enterprise in MongoDB compatibility mode

**References**:
- Firestore Enterprise: https://firebase.google.com/docs/firestore/enterprise/overview-enterprise-edition-modes
- MongoDB Compatibility Mode: https://firebase.google.com/docs/firestore/enterprise/mongodb-compatibility-overview

| Setting          | Value                              |
| ---------------- | ---------------------------------- |
| Mode             | MongoDB compatibility              |
| Region           | `asia-southeast1`                  |
| Driver           | MongoDB Go driver (standard wire protocol) |
| Security         | Backend-only access (no direct client access) |
| Network access   | Private endpoint or IP allowlist from Cloud Run |
| Backup           | Enabled (managed by Firestore Enterprise) |

---

#### INFRA-007: Google Cloud Logging & Monitoring

**Purpose**: Centralized observability.

**Configuration**:

- **Structured logging** from Cloud Run (JSON format)
- **Log sinks**: Route error logs to a dedicated log bucket with 90-day retention
- **Alerts**:
  - Error rate > 1% of requests over 5 minutes
  - Latency P95 > 2 seconds over 5 minutes
  - Cloud Run instance memory > 80%
  - Any masked 500 error logged
- **Dashboards**: Request rate, latency, error rate, Cloud Run instance count

---

### CI/CD Pipeline

**Tool**: GitHub Actions (assumed, given `.github/` directory exists)

**Pipeline stages**:

```
┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐
│   Lint   │───▶│   Test   │───▶│  Build   │───▶│  Deploy  │
└──────────┘    └──────────┘    └──────────┘    └──────────┘
```

| Stage   | Frontend                        | Backend                        |
| ------- | ------------------------------- | ------------------------------ |
| Lint    | ESLint, Stylelint               | golangci-lint                  |
| Test    | Vitest (unit), Playwright (E2E) | `go test`                      |
| Build   | `nuxt generate`                 | Docker build                   |
| Deploy  | Firebase deploy                 | Cloud Run deploy               |

**Branch strategy**:
- `main` → Production
- `staging` → Staging environment
- Feature branches → PR preview (optional)

---

#### INFRA-008: Sitemap Generation (Cloud Function + Cloud Scheduler)

**Purpose**: Periodically regenerate the sitemap and store it in Firestore for serving via the `GET /sitemap.xml` API endpoint.

##### INFRA-008a: Cloud Function — `generate-sitemap`

**Purpose**: Internal Cloud Function that generates the sitemap XML from article data in Firestore.

**Configuration**:

| Setting              | Value                                              |
| -------------------- | -------------------------------------------------- |
| Function name        | `generate-sitemap`                                 |
| Runtime              | Go (Cloud Functions Gen 2)                         |
| Region               | `asia-southeast1`                                  |
| Memory               | 256 MB                                             |
| Timeout              | 60 seconds                                         |
| Trigger              | HTTP (invoked by Cloud Scheduler)                  |
| Ingress              | Internal only (no public access)                   |
| VPC connector        | Connected to the project VPC (see INFRA-009)       |
| Authentication       | Requires authentication (OIDC token from Cloud Scheduler service account) |

**Sitemap Generation Logic**:

1. Query all published articles from `technical_articles` and `blog_articles` collections.
2. Include static pages: `/`, `/technical`, `/blog`, `/socials`, `/others`, `/privacy`.
3. Article URLs SHALL include the `.md` extension (e.g., `https://tjmonsi.com/technical/article-title-2025-01-15-1030.md`).
4. Build sitemap XML per the [Sitemaps protocol](https://www.sitemaps.org/protocol.html).
5. Write the generated XML to the `sitemap` Firestore collection (DM-010).
6. The `GET /sitemap.xml` public endpoint reads from this collection (BE-API-011).

##### INFRA-008b: Cloud Scheduler — `trigger-sitemap-generation`

**Configuration**:

| Setting              | Value                                              |
| -------------------- | -------------------------------------------------- |
| Job name             | `trigger-sitemap-generation`                       |
| Schedule             | Every 6 hours (`0 */6 * * *`)                      |
| Target               | Cloud Function `generate-sitemap` (HTTP trigger)   |
| HTTP method          | POST                                               |
| Authentication       | OIDC token (service account with Cloud Functions invoker role) |
| Region               | `asia-southeast1`                                  |
| Retry config         | Max 3 retries with exponential backoff             |

**Notes**:
- The Cloud Function runs internally only and is NOT accessible from the public internet.
- The 6-hour schedule balances freshness with cost. Adjust based on content update frequency.

---

##### INFRA-008c: Cloud Function — `process-rate-limit-logs`

**Purpose**: Process Cloud Armor rate-limit (429) log entries via a log sink and write offense records to the `rate_limit_offenders` Firestore collection (DM-009). This bridges the gap between Cloud Armor's request-level rate limiting and the application's progressive banning logic — Cloud Armor blocks requests before they reach Cloud Run, so the Go application cannot directly observe rate-limited requests.

**Configuration**:

| Setting              | Value                                              |
| -------------------- | -------------------------------------------------- |
| Function name        | `process-rate-limit-logs`                          |
| Runtime              | Go (Cloud Functions Gen 2)                         |
| Region               | `asia-southeast1`                                  |
| Memory               | 256 MB                                             |
| Timeout              | 60 seconds                                         |
| Trigger              | Cloud Logging log sink (via Pub/Sub)               |
| Ingress              | Internal only (no public access)                   |
| VPC connector        | Connected to the project VPC (see INFRA-009)       |
| Authentication       | Service account with Firestore read/write access   |

**Log Sink Configuration**:

- A Cloud Logging log sink SHALL be configured to route Cloud Armor rate-limit events to a Pub/Sub topic.
- Log sink filter: Cloud Armor logs where the response status is `429` (rate limit exceeded).
- The Pub/Sub topic triggers the `process-rate-limit-logs` Cloud Function.

**Processing Logic**:

1. Receive Cloud Armor log entry from Pub/Sub.
2. Extract the client IP address from the log entry.
3. Look up or create the offender record in the `rate_limit_offenders` collection (DM-009) by client IP.
4. Increment `offense_count` and append to `offense_history`.
5. Evaluate progressive banning thresholds (see SEC-002 in [06-security-specifications.md](06-security-specifications.md)):
   - 5 offenses within 7 days → set 30-day ban.
   - 2 offenses after 30-day ban expires → set 90-day ban.
   - 2 offenses after 90-day ban expires → set indefinite ban.
6. Write updated record to Firestore.

**Notes**:
- The Cloud Function runs internally only and is NOT accessible from the public internet.
- The Go application (Cloud Run) reads DM-009 on each incoming request to check ban status and enforce the appropriate response code (403 or 404).

---

#### INFRA-009: VPC Network

**Purpose**: Provide private networking for Cloud Run and Cloud Functions, restricting egress to Google Cloud APIs only.

**Configuration**:

| Setting                  | Value                                              |
| ------------------------ | -------------------------------------------------- |
| VPC name                 | `personal-website-vpc`                             |
| Region                   | `asia-southeast1`                                  |
| Subnet (Cloud Run)       | Minimum subnet (e.g., `/28`) for Cloud Run VPC connector |
| Subnet (Cloud Functions) | Minimum subnet (e.g., `/28`) for Cloud Functions VPC connector |
| Private Google Access    | Enabled (allows access to Google Cloud APIs without public IPs) |
| NAT                      | None (no Cloud NAT router)                         |
| Firewall rules           | Default deny egress to internet; allow egress to Google Cloud API ranges only |

**VPC Connectors**:

- **Cloud Run VPC connector**: Connects the Go backend API (INFRA-003) to the VPC. Enables private access to Firestore Enterprise and other Google Cloud services.
- **Cloud Functions VPC connector**: Connects the sitemap generation Cloud Function (INFRA-008a) and the log processing Cloud Function (INFRA-008c) to the VPC. Enables private access to Firestore Enterprise.

**Network Policy**:

- Cloud Run and Cloud Functions SHALL route all egress traffic through the VPC.
- Egress SHALL be restricted to Google Cloud API endpoints only (via Private Google Access).
- No outbound internet access is required — all external dependencies are Google Cloud services.
- No Cloud NAT router is provisioned to minimize cost and attack surface.

---

### Network Diagram

```
                    Internet
                       │
                       ▼
              ┌─────────────────┐
              │   Cloud DNS     │
              │  tjmonsi.com    │
              │ api.tjmonsi.com │
              └────────┬────────┘
                       │
                       ▼
              ┌─────────────────┐
              │  Cloud Armor    │
              │  (WAF / DDoS)   │
              └────────┬────────┘
                       │
                       ▼
              ┌─────────────────┐
              │  Cloud Load     │
              │  Balancer (L7)  │
              └───┬─────────┬───┘
                  │         │
        ┌─────────┘         └─────────┐
        ▼                             ▼
┌───────────────┐       ┌──── VPC (asia-southeast1) ────┐
│   Firebase    │       │                                │
│   Hosting +   │       │  ┌───────────────┐             │
│   Functions   │       │  │   Cloud Run   │             │
│   (SPA)       │       │  │   (Go API)    │             │
│               │       │  │   0-N inst.   │             │
│  Rewrites:    │       │  └───────┬───────┘             │
│  /sitemap.xml─│───────│──────────┘                     │
└───────────────┘       │          │                      │
                        │          ▼                      │
                        │  ┌───────────────┐             │
                        │  │   Firestore   │             │
                        │  │   Enterprise  │             │
                        │  │   asia-se1    │             │
                        │  └───────┬───────┘             │
                        │          ▲                      │
                        │  ┌───────┴───────┐             │
Cloud Scheduler ───────▶│  │Cloud Function │             │
                        │  │(Sitemap Gen)  │             │
                        │  └───────────────┘             │
                        │                                │
                        │  ┌───────────────┐             │
Cloud Armor Log Sink ──▶│  │Cloud Function │             │
                        │  │(Log Proc.)    │             │
                        │  └───────────────┘             │
                        └────────────────────────────────┘
```
